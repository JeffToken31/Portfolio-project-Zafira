## <img src="image.png" alt="alt text" width="20" height="20" style="vertical-align: middle;" /> GitHub Workflow – Source Code Management
We use GitHub to manage our source code. Here is our workflow and rules:

### 1️⃣ Branches
- Main: Stable, production-ready code.
- Dev: Development branch, where all new features and fixes are integrated before going to Main.
- Issue branches: One branch per issue (fix, add, feat, etc.).

### 2️⃣ Development Workflow
1. Create an Issue before commit   
Title should start with a keyword describing the change:
    Fix → bug fix
    Add → add a feature
    Feat → new functionality
Example: Fix login page

2. Create a local branch  
```
git checkout -b <title>/#<issue_number>

Example: 
git checkout -b fix-login/#12
```

3. Develop and commit  
```
git commit -m '(close #<issue_number>) : description of the commit'

Example: 
git commit -m '(close #12) : corrected login form'
```

4. Push & Pull Request  
```
git push origin <title>/#<issue_number>
```

- Open a Pull Request from your branch to Dev.
- After review and approval → merge into Dev.

5. Merge Dev into Main  
- Once Dev is stable and tested, merge into Main for production.

### 3️⃣ Workflow Diagram (Concise View)
```
Main (stable) <----- Dev (development) <----- Feature/Issue branches
```

### ✅ Benefits
Clear traceability of changes via Issues.  
Organized development with isolated feature branches.  
Gradual and controlled integration into Main.  
<br>

## <img src="image-1.png" alt="alt text" width="20" height="20" style="vertical-align: middle;" /> Quality Assurance (QA) Strategy

### Layer-by-Layer Strategy
#### Frontend (Next.js)
- Unit Tests: React components, hooks, utilities
- Integration Tests: Complete pages, Context Providers
- E2E Tests: Critical user journeys

#### Backend (NestJS)
- Unit Tests: Services, controllers, repositories
- Integration Tests: API endpoints, database
- Contract Tests: External APIs (Google OAuth, WeezEvent)

#### Database
- Data Tests: Migrations, constraints, performance
- Backup Tests: Backup and restore procedures

### Testing tools
### 1️⃣ Unit Tests
It tests individual functions or components.
- Jest:
    - Test a single behavior per test
    - Keep tests fast and run on every commit  
Example: 
    - Validating email or form inputs

### 2️⃣ Integration Tests
It verifies multiple modules work together correctly.
- Supertest, SQL:
    - Cover critical flows
    - Automate tests in CI pipelines  
Example: 
    - Form submission to backend returns correct response
    - Blog controller

### 3️⃣ API Tests
It ensures API endpoints function as expected and follows documentation.
- Postman, Swagger:
    - Automate Postman collection runs in CI/CD
    - Keep Swagger docs updated  
Example:
    - Test GET/POST/PUT/DELETE endpoints

### 4️⃣ End-to-End (E2E) Tests
We test the complete user journey.
- Cypress or Playwright (optional):
    - Focus on critical user flows
    - Maintain stable and maintainable tests  
Example: 
    - Beneficiary journey

### 5️⃣ Manual Testing
That verifies critical functionality and UX  
- Browser, mobile emulator, QA checklists
    - Document test results and bugs
    - Prioritize high-impact features  
Example: 
    - Responsive design verification

### Zafira - Possible Specific Testing Strategy
|Title|Tests|
|-----|-----|
|Beneficiary Journey|Google OAuth login|
||Beneficiary dashboard navigation|
||Action request submission|
||Testimonial submission|
||Resquest status tracking|
|Admin Journey|Admin authentication|
||Blog article management|
||Action request validation|
||Partner management|
||Statistics consultation|
|External Integrations|Google OAuth API|
||WeezEvent API|
||HelloAsso API|
